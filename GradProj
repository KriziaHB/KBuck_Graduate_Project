# Student: Krizia Houston Buck
# Faculty: Dr. Emre Celebi
# University of Central Arkansas
# Summer 2017
# Graduate Project

# PIL for manipulating images
import PIL
from PIL import Image

# read image #
def readImage():
   # print('in readImage')

    # Max on paddleboard  -  JPEG, 750x1334, RGB: IMG_5455.JPG
    pic1 = "IMG_5455.JPG"
    # Hiking Gatlinburg  -  JPEG, 2320x3088, RGB: ELOF9870.jpg
    pic2 = "ELOF9870.jpg"
    # Max in grass  -  JPEG, 750x1334, RGB: IMG_5331.JPG
    pic3 = "IMG_5331.JPG"
    # Max paddleboard from behind  -  JPEG, 750x1334, RGB: IMG_5457.JPG
    pic4 = "IMG_5457.JPG"
    # Josh on bike  -  JPEG, 4032x3024, RGB: IMG_5672.JPG
    pic5 = "IMG_5672.JPG"


##### User selects image to use
    userIn = input('Select which image to use (1-5): ')
    if (userIn =='1'):
        picture = pic1
    elif (userIn == '2'):
        picture = pic2
    elif (userIn == '3'):
        picture = pic3
    elif (userIn == '4'):
        picture = pic4
    elif (userIn == '5'):
        picture = pic5
    else:
        picture = pic1

    im = Image.open(picture)
    im.show()

##### User selects whether to go to maniImage
    userinput = input('Go into maniImage? (y/n): ')
    if (userinput == 'y'):
##      # Manipulate images (pixels)
        imMani = maniImage(im)
        pixels = imMani.load()
    else:
        pixels = im.load()


    return(pixels)
# end of readImage #



# manipulate images #
def maniImage(im):
    print (im.format, im.size, im.mode)

    # Rotate an image
    im.rotate(45).show()

    # multiply each pixel by a constant
    out = im.point(lambda i: i * 2)
    out.show()

    # Split and merge bands (rgb)
    r, g, b = im.split()
    r.show()
    g.show()
    b.show()
    imM1 = Image.merge("RGB", (r, b, g))
    imM2 = Image.merge("RGB", (g, b, r))
    imM3 = Image.merge("RGB", (g, r, b))
    imM4 = Image.merge("RGB", (b, g, r))
    imM5 = Image.merge("RGB", (b, r, g))
    imM1.show()
    imM2.show()
    imM3.show()
    imM4.show()
    imM5.show()

    # get pixel values as (r,g,b) at indices
    data = list(im.getdata())
    print('Get Data: ')
    print(data)

    # return manipulated image
    return(im)
# end of maniImage #



# Online K-Means #
def kmeans(k, pix, initChoice, pChoice, LR):
    print("in kmeans")
    end = 0

    # iterate through pixels to form clusters
    while (end < 5):
        print("while")
        end += 1

    # return to main
    out = 0
    return(out)
# end of kmeans #



# K Nearest Neighbor #
def knn():
    print("in knn")
# end of knn #



# call everything from main #
def main():
    print("Krizia Houston Buck - UCA Summer 2017 - Graduate Project - Dr. Emre Celebi")

    # read in image, manipulatation possible, return individual pixels
    pix = readImage()
 #   x, y = 2, 4; print('Pixels loaded individually for access. Example: '); print('Pixel value of [' + str(x) + ', ' + str(y) + ']'); print(pix[x,y])


##### User inputs cluster number
    uIn = input('Number of clusters (k): ')
    k = int(uIn)

##### User chooses type of Initialization
    uIn1 = input('[1] Linear Initialization, [2] Random Initialization, or [3] Most Common Color Initialization: ')
    if (uIn1 == '1'):
        initChoice = 1
    elif (uIn1 == '2'):
        initChoice = 2
    elif (uIn1 == '3'):
        initChoice = 3
    else:
        initChoice = 1

##### User chooses type of Presentation Style
    uIn2 = input('Presentation Style of [1] Cyclic or [2] Random: ')
    if (uIn2 == '2'):
        pChoice = 2
    else:
        pChoice = 1

##### User chooses the Learning Rate
    uIn3 = input('Learning Rate of [1] 1/(1+t) or [2] sqrt(1/(1+t)): ')
    if (uIn3 == '2'):
        LR = 2
    else:
        LR = 1


    # cluster data using Online K-Means
    out = kmeans(k, pix, initChoice, pChoice, LR)
# end of main #



# call main #
if __name__ == '__main__':
    main()
# end of program #



#### HELP ####

## http://effbot.org/imagingbook/introduction.htm
    # Split and merge bands (rgb)
    # r, g, b = im.split()
    # r.show()
    # g.show()
    # b.show()
    # imM1 = Image.merge("RGB", (r, b, g))
    # imM2 = Image.merge("RGB", (g, b, r))
    # imM3 = Image.merge("RGB", (g, r, b))
    # imM4 = Image.merge("RGB", (b, g, r))
    # imM5 = Image.merge("RGB", (b, r, g))
    # imM1.show()
    # imM2.show()
    # imM3.show()
    # imM4.show()
    # imM5.show()



    # Manipulate individual bands (RGB)  -  imout = im.point(lambda i: expression and 255)
    # split the image into individual bands  -
    # source = im.split()
    # R, G, B = 0, 1, 2
    # # select regions where red is less than 100
    # mask = source[R].point(lambda i: i < 100 and 255)
    # # process the green band
    # out = source[G].point(lambda i: i * 0.7)
    # # paste the processed band back, but only where red was < 100
    # source[G].paste(out, None, mask)
    # # build a new multiband image
    # im = Image.merge(im.mode, source)
    # im.show()
    # im.save("output.jpg")


    # getcolors
    # im.getcolors() ⇒ a list of(count, color) tuples or None
    # im.getcolors(maxcolors) ⇒ a list of(count, color) tuples or None
    # try to get (count, colors)
    # c = im.getcolors()
    # print('Get Colors: ')
    # print(c)
    # # get pixel values as (r,g,b) at indices
    # d = list(im.getdata())
    # print('Get Data: ')
    # print(d)
    # # get individual pixel
    # pix = im.load()
    # print('Pixels loaded individually for access: ')
    # x, y = 10, 20
    # print(pix[x, y])